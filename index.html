<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>åå­¸é™¢ï½œAI è–èª•æ¨¹é©šå–œé­”æ³•é«”é©— </title>
  <link href="https://fonts.googleapis.com/css2?family=Corinthia:wght@400;700&display=swap" rel="stylesheet">
  <style>
    body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; }
    #canvas-container { position: fixed; inset: 0; z-index: 1; }
    #video-preview { position: fixed; left: 16px; bottom: 16px; width: clamp(100px, 25vw, 160px); aspect-ratio: 4/3; border-radius: 14px; transform: scaleX(-1); border: 2px solid rgba(255,255,255,0.18); z-index: 10; object-fit: cover; opacity: 0.55; }
    
    #big-title { position: fixed; top: 1vh; left: 50%; transform: translateX(-50%); z-index: 13; pointer-events: none; font-family: "Corinthia", cursive; color: #ffffff; font-size: clamp(55px, 14vw, 130px); text-shadow: 0 0 15px rgba(255, 60, 60, 0.9); white-space: nowrap; }
    #text-layer { position: fixed; top: clamp(160px, 28vh, 230px); left: 50%; transform: translateX(-50%); z-index: 12; width: 90vw; text-align: center; pointer-events: none; color: rgba(255,255,255,0.92); font-weight: bold; letter-spacing: 2px; font-size: 14px; text-shadow: 0 2px 4px rgba(0,0,0,0.5); }

    #ui-panel { position: fixed; top: 16px; right: 16px; width: 260px; padding: 16px; background: rgba(20,20,35,0.85); backdrop-filter: blur(10px); border-radius: 16px; border: 1px solid rgba(255,255,255,0.12); color: #fff; z-index: 100; transition: 0.3s ease; }
    @media (max-width: 600px) { #ui-panel { transform: translateX(calc(100% + 20px)); } #ui-panel.show { transform: translateX(0); } }
    #ui-toggle { position: fixed; top: 16px; right: 16px; width: 44px; height: 44px; background: rgba(34,255,136,0.9); border-radius: 12px; display: none; align-items: center; justify-content: center; z-index: 101; cursor: pointer; }
    @media (max-width: 600px) { #ui-toggle { display: flex; } }
    
    .color-row { display: flex; flex-wrap: wrap; gap: 8px; margin: 10px 0; }
    .cbtn { width: 24px; height: 24px; border-radius: 50%; border: 2px solid #fff; cursor: pointer; }
    .toggle-row { display:flex; align-items:center; justify-content:space-between; margin-top: 10px; }
    .switch { width: 44px; height: 24px; background: rgba(255,255,255,0.14); border-radius: 999px; position: relative; cursor: pointer; }
    .knob { width: 18px; height: 18px; border-radius: 50%; background: #fff; position: absolute; top: 3px; left: 3px; transition: 0.2s; }
    .switch.on .knob { left: 23px; background: #22ff88; }
    
    #status { position: fixed; inset: 0; display: flex; flex-direction: column; align-items: center; justify-content: center; color: #fff; z-index: 200; background: #000; text-align: center; transition: opacity 0.5s; }
    #start-btn { margin-top: 24px; padding: 16px 40px; border-radius: 50px; border: 0; background: #22ff88; font-weight: 800; cursor: pointer; font-size: 20px; box-shadow: 0 0 20px rgba(34,255,136,0.5); color: #000; }

    /* [ä¿®æ”¹] é©šå–œå¡ç‰‡æ¨£å¼ï¼šæ”¯æ´é›™åœ–æ»¾å‹•/æ’åˆ— */
    #reveal-card { 
      position: fixed; left: 50%; top: 55%; transform: translate(-50%, -50%) scale(0.9); 
      width: min(90vw, 500px); /* åŠ å¯¬ä¸€é»ä»¥å®¹ç´é›™åœ– */
      background: rgba(10,10,18,0.72); border-radius: 18px; padding: 12px; 
      z-index: 20; opacity: 0; transition: 0.3s ease; pointer-events: none; 
      max-height: 80vh; overflow-y: auto; /* æ‰‹æ©Ÿç‰ˆå¦‚æœåœ–å¤ªé•·å¯ä»¥æ»‘å‹• */
    }
    #reveal-card.show { opacity: 1; transform: translate(-50%, -50%) scale(1); pointer-events: auto; }
    
    /* é›™åœ–å®¹å™¨ */
    .gallery { display: flex; gap: 8px; }
    .gallery img { 
      width: 100%; flex: 1; border-radius: 10px; object-fit: cover; 
      aspect-ratio: 1/1; /* è®“åœ–ç‰‡ä¿æŒæ­£æ–¹å½¢ï¼Œæˆ–è€…ä½ å¯ä»¥æ‹¿æ‰é€™è¡Œ */
    }
    /* æ‰‹æ©Ÿç‰ˆæ”¹ç‚ºç›´å‘æ’åˆ— */
    @media (max-width: 450px) {
        .gallery { flex-direction: column; }
    }

    /* å…‰é»ç‰¹æ•ˆæ¨£å¼ */
    .sparkle {
      position: fixed; pointer-events: none; z-index: 999;
      width: 40px; height: 40px;
      background: radial-gradient(circle, #fff 10%, #ffd700 40%, transparent 70%);
      border-radius: 50%; mix-blend-mode: screen;
      animation: spark-anim 0.5s ease-out forwards;
    }
    @keyframes spark-anim {
      0% { transform: scale(0); opacity: 1; }
      100% { transform: scale(2.5); opacity: 0; }
    }
  </style>
</head>
<body>

  <div id="status">
    <h1 style="font-family: 'Corinthia', cursive; font-size: 60px; margin: 0;"> Sum Sphere </h1>
    <p style="opacity: 0.8; margin-top: 10px;">ğŸ‘‹ æ®æ‰‹ç§»å‹• | ğŸ– å¼µé–‹è§£é– | ğŸ‘Œ æåˆé­”æ³• </p>
    <button id="start-btn">ğŸµ å•Ÿå‹•è–èª•é­”æ³•</button>
    <p style="margin-top: 20px; font-size: 12px; color: #aaa;">è«‹é–‹å•Ÿæ”å½±æ©Ÿæ¬Šé™ï¼Œæ‰èƒ½é«”é©—è–èª•é­”æ³•å–”ï¼</p>
  </div>

  <video id="video-preview" playsinline muted></video>
  <div id="big-title">Merry Christmas</div>
  <div id="text-layer">æ‰‹æŒå¼µé–‹ âœ è§£é–é©šå–œ</div>

  <div id="reveal-card">
    <div class="gallery">
        <img src="./xmas.jpg" alt="Surprise 1" />
        <img src="./xmas2" alt="Surprise 2" />
    </div>
    <div style="color:#fff; text-align:center; margin-top:10px; font-size:13px;">çµ¦ä½ é›™å€é©šå–œï¼è–èª•å¿«æ¨‚ âœ¨</div>
  </div>

  <audio id="bgm" src="./xmas_song.mp3.m4a" loop preload="auto"></audio>
  
  <div id="ui-toggle">âš™ï¸</div>
  <div id="ui-panel">
    <h2 style="font-size:16px; margin:0;">âœ¨ ç‡ˆæ³¡è‰²å½©æ§åˆ¶</h2>
    <div class="color-row">
      <div class="cbtn" style="background:#ff4d4d" data-c="#ff4d4d"></div>
      <div class="cbtn" style="background:#ffd700" data-c="#ffd700"></div>
      <div class="cbtn" style="background:#22ff88" data-c="#22ff88"></div>
      <div class="cbtn" style="background:#00AAFF" data-c="#00AAFF"></div>
      <div class="cbtn" style="background:#a29bfe" data-c="#a29bfe"></div>
      <div class="cbtn" style="background:#ffffff" data-c="#ffffff"></div>
    </div>
    <div class="toggle-row">
      <label style="font-size:12px;">æ¼¸å±¤æ¨¡å¼</label>
      <div id="gradSwitch" class="switch on"><div class="knob"></div></div>
    </div>
    <button id="audio-btn" style="width:100%; margin-top:10px; background:rgba(34,255,136,0.3); color:#fff; border:none; padding:8px; border-radius:8px; cursor:pointer;">ğŸ”Š éŸ³æ¨‚æ’­æ”¾ä¸­</button>
  </div>

  <div id="canvas-container"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

  <script>
    // --- Scene Setup ---
    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x000000, 35, 120);
    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.getElementById('canvas-container').appendChild(renderer.domElement);
    camera.position.set(0, 3, 52);

    const group = new THREE.Group();
    scene.add(group);
    scene.add(new THREE.AmbientLight(0xffffff, 0.8));
    const light = new THREE.DirectionalLight(0xffffff, 1.0);
    light.position.set(10, 20, 10);
    scene.add(light);

    const isMobile = window.innerWidth < 600;
    let currentBulbColor = new THREE.Color(0xff4d4d);
    let isGradient = true;

    // --- Tree Particles ---
    const particleCount = isMobile ? 7000 : 14000;
    const treeGeometry = new THREE.BufferGeometry();
    const positions = new Float32Array(particleCount * 3);
    const colors = new Float32Array(particleCount * 3);
    const baseTargets = new Float32Array(particleCount * 3);
    const explodedTargets = new Float32Array(particleCount * 3);
    const yMin = -20, yMax = 16;
    
    function radiusAtY(y) { 
        const t = (y - yMin) / (yMax - yMin); 
        return 15.5 * (1 - t) + 0.7; 
    }
    
    const treeBaseColor = new THREE.Color(0x1a5c2d);
    const treeTopColor = new THREE.Color(0xffd700);

    for (let i = 0; i < particleCount; i++) {
      const idx = i * 3;
      const y = yMin + Math.random() * (yMax - yMin);
      const r = radiusAtY(y);
      const t = (y - yMin) / (yMax - yMin);
      const angle = (t * Math.PI * 2 * 10) + (Math.random()-0.5)*0.8;
      const x = Math.cos(angle) * r;
      const z = Math.sin(angle) * r;
      
      baseTargets[idx] = x; baseTargets[idx+1] = y; baseTargets[idx+2] = z;
      const dir = new THREE.Vector3(x, y*0.2, z).normalize();
      explodedTargets[idx] = x + dir.x * 40; explodedTargets[idx+1] = y + dir.y * 40; explodedTargets[idx+2] = z + dir.z * 40;
      
      positions[idx] = x; positions[idx+1] = y; positions[idx+2] = z;
      const col = treeBaseColor.clone().lerp(treeTopColor, t);
      colors[idx] = col.r; colors[idx+1] = col.g; colors[idx+2] = col.b;
    }
    treeGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    treeGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    
    // [è¨­å®š] ç²’å­åšåº¦ 0.48
    group.add(new THREE.Points(treeGeometry, new THREE.PointsMaterial({ size: 0.48, transparent: true, blending: THREE.AdditiveBlending, vertexColors: true })));

    // --- Ribbon ---
    const ribbonPts = [];
    for (let i = 0; i <= 200; i++) {
      const tt = i / 200;
      const y = yMin + (yMax - yMin) * tt;
      const r = radiusAtY(y) * 1.05;
      const a = tt * Math.PI * 2 * 7.2;
      ribbonPts.push(new THREE.Vector3(Math.cos(a)*r, y, Math.sin(a)*r));
    }
    const ribbonCurve = new THREE.CatmullRomCurve3(ribbonPts);
    
    // [è¨­å®š] æ¥µç´°é‡‘å±¬çµ² 0.05
    const ribbonMesh = new THREE.Mesh(new THREE.TubeGeometry(ribbonCurve, 200, 0.05, 8, false), new THREE.MeshStandardMaterial({ color: 0xff3333 }));
    group.add(ribbonMesh);

    // --- Bulbs ---
    const bulbCount = 80;
    const bulbGroup = new THREE.Group();
    const bulbList = [];
    const gold = new THREE.Color(0xffd700);

    function updateBulbVisuals() {
      bulbList.forEach(item => {
        const t = (item.mesh.position.y - yMin) / (yMax - yMin);
        const finalCol = isGradient ? currentBulbColor.clone().lerp(gold, t) : currentBulbColor;
        item.mesh.material.color.copy(finalCol);
        item.mesh.material.emissive.copy(finalCol);
      });
    }

    for (let i = 0; i < bulbCount; i++) {
      const t = Math.random();
      const pos = ribbonCurve.getPoint(t);
      const off = 1.3;
      pos.x += (Math.random()-0.5)*off; pos.y += (Math.random()-0.5)*off; pos.z += (Math.random()-0.5)*off;
      const mesh = new THREE.Mesh(new THREE.SphereGeometry(0.38, 8, 8), new THREE.MeshStandardMaterial({ roughness: 0.1, emissiveIntensity: 0.8 }));
      mesh.position.copy(pos);
      bulbList.push({ mesh });
      bulbGroup.add(mesh);
    }
    group.add(bulbGroup);
    updateBulbVisuals();

    // --- Star ---
    function makeStar() {
      const starShape = new THREE.Shape();
      const points = 5;
      const outerRadius = 2.5;
      const innerRadius = 1.0;
      for (let i = 0; i < points * 2; i++) {
        const radius = i % 2 === 0 ? outerRadius : innerRadius;
        const angle = (i / (points * 2)) * Math.PI * 2 - Math.PI / 2;
        if (i === 0) starShape.moveTo(Math.cos(angle) * radius, Math.sin(angle) * radius);
        else starShape.lineTo(Math.cos(angle) * radius, Math.sin(angle) * radius);
      }
      const starGeo = new THREE.ExtrudeGeometry(starShape, { depth: 0.4, bevelEnabled: false });
      const starMesh = new THREE.Mesh(starGeo, new THREE.MeshStandardMaterial({color:0xffd700, emissive:0xffd700, emissiveIntensity:1.2}));
      starMesh.position.y = yMax + 3.5;
      starMesh.scale.set(0.6, 0.6, 0.6);
      
      const canvas = document.createElement('canvas'); canvas.width=128; canvas.height=128;
      const ctx = canvas.getContext('2d');
      const g = ctx.createRadialGradient(64,64,0,64,64,64); g.addColorStop(0,'rgba(255,215,0,1)'); g.addColorStop(1,'rgba(255,215,0,0)');
      ctx.fillStyle=g; ctx.fillRect(0,0,128,128);
      const halo = new THREE.Sprite(new THREE.SpriteMaterial({map:new THREE.CanvasTexture(canvas), blending:THREE.AdditiveBlending}));
      halo.position.copy(starMesh.position); halo.scale.set(15,15,1);
      return {starMesh, halo};
    }
    const starPack = makeStar();
    group.add(starPack.starMesh, starPack.halo);

    // --- Snow ---
    const snowCount = isMobile ? 500 : 1000;
    const snowGeo = new THREE.BufferGeometry();
    const snowPos = new Float32Array(snowCount * 3);
    for(let i=0; i<snowCount*3; i++) snowPos[i] = (Math.random()-0.5)*140;
    snowGeo.setAttribute('position', new THREE.BufferAttribute(snowPos, 3));
    const snow = new THREE.Points(snowGeo, new THREE.PointsMaterial({color:0xffffff, size:0.3, transparent:true, opacity:0.6}));
    scene.add(snow);

    // DOM å…‰é»ç”Ÿæˆå‡½å¼
    function createSparkle(normX, normY) {
        const s = document.createElement('div');
        s.className = 'sparkle';
        const x = (1 - normX) * window.innerWidth;
        const y = normY * window.innerHeight;
        s.style.left = (x - 20) + 'px';
        s.style.top = (y - 20) + 'px';
        document.body.appendChild(s);
        setTimeout(() => s.remove(), 500);
    }

    // --- Interaction & MediaPipe ---
    let explodeFactor = 0, targetExplode = 0;
    let handRotation = 0, autoRotation = 0;
    let targetMoveX = 0;
    let currentMoveX = 0;
    
    let lastPinchTime = 0;

    const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6 });
    hands.onResults((res) => {
      if(res.multiHandLandmarks && res.multiHandLandmarks[0]) {
        const h = res.multiHandLandmarks[0];
        
        targetExplode = Math.hypot(h[4].x-h[20].x, h[4].y-h[20].y) > 0.35 ? 1 : 0;
        handRotation = (h[9].x - 0.5) * Math.PI * 2;
        targetMoveX = (0.5 - h[9].x) * 20;

        const pinchDist = Math.hypot(h[4].x - h[8].x, h[4].y - h[8].y);
        const now = Date.now();
        if (pinchDist < 0.06 && now - lastPinchTime > 150) {
            createSparkle(h[8].x, h[8].y);
            lastPinchTime = now;
        }

      } else { 
        targetExplode = 0; 
        targetMoveX = 0;
      }
    });

    function animate() {
      requestAnimationFrame(animate);
      autoRotation += 0.005;
      group.rotation.y = autoRotation + handRotation;

      currentMoveX += (targetMoveX - currentMoveX) * 0.1;
      group.position.x = currentMoveX;

      explodeFactor += (targetExplode - explodeFactor) * 0.1;
      
      const p = treeGeometry.attributes.position.array;
      for(let i=0; i<particleCount; i++){
        const idx = i*3;
        const tx = baseTargets[idx] + (explodedTargets[idx]-baseTargets[idx])*explodeFactor;
        const ty = baseTargets[idx+1] + (explodedTargets[idx+1]-baseTargets[idx+1])*explodeFactor;
        const tz = baseTargets[idx+2] + (explodedTargets[idx+2]-baseTargets[idx+2])*explodeFactor;
        p[idx] += (tx - p[idx])*0.15; p[idx+1] += (ty - p[idx+1])*0.15; p[idx+2] += (tz - p[idx+2])*0.15;
      }
      treeGeometry.attributes.position.needsUpdate = true;
      
      const s = 1 - explodeFactor;
      starPack.starMesh.scale.set(0.6*s, 0.6*s, 0.6*s);
      starPack.halo.scale.set(15*s, 15*s, 1);
      ribbonMesh.scale.set(s, s, s); bulbGroup.scale.set(s, s, s);
      snow.position.y -= 0.12; if(snow.position.y < -40) snow.position.y = 40;
      
      document.getElementById('reveal-card').classList.toggle('show', explodeFactor > 0.8);
      starPack.starMesh.rotation.y += 0.02;
      renderer.render(scene, camera);
    }

    // --- Audio & Start Control ---
    const bgm = document.getElementById('bgm');
    const audioBtn = document.getElementById('audio-btn');

    async function tryPlayMusic() {
      bgm.muted = false;
      bgm.volume = 1.0;
      try {
        await bgm.play();
        audioBtn.innerHTML = "ğŸ”Š éŸ³æ¨‚æ’­æ”¾ä¸­";
        audioBtn.style.background = "rgba(34,255,136,0.3)";
      } catch (e) {
        console.warn("è‡ªå‹•æ’­æ”¾æ””æˆª:", e);
        audioBtn.innerHTML = "ğŸ”ˆ é»æ­¤é–‹å•ŸéŸ³æ¨‚";
      }
    }

    audioBtn.onclick = () => {
      if (bgm.paused) { bgm.play(); audioBtn.innerHTML = "ğŸ”Š éŸ³æ¨‚æ’­æ”¾ä¸­"; audioBtn.style.background = "rgba(34,255,136,0.3)"; }
      else { bgm.pause(); audioBtn.innerHTML = "ğŸ”ˆ éŸ³æ¨‚å·²æš«åœ"; audioBtn.style.background = "rgba(255,255,255,0.1)"; }
    };

    document.getElementById('start-btn').onclick = async function() {
      await tryPlayMusic();
      document.getElementById('status').style.opacity = '0';
      setTimeout(() => { document.getElementById('status').style.display = 'none'; }, 500);
      animate();
      const videoElement = document.getElementById('video-preview');
      const cam = new Camera(videoElement, { 
        onFrame: async () => { await hands.send({image: videoElement}); }, 
        width: 320, height: 240 
      });
      cam.start();
    };

    document.querySelectorAll('.cbtn').forEach(btn => {
      btn.onclick = () => {
        const hex = btn.dataset.c;
        const selectedColor = new THREE.Color(hex);
        currentBulbColor = selectedColor; 

        const newBase = selectedColor.clone().multiplyScalar(0.25); 
        const newTop = selectedColor.clone().lerp(new THREE.Color(0xffffff), 0.2); 

        const colorsAttr = treeGeometry.attributes.color;
        const colorArr = colorsAttr.array;

        for(let i=0; i<particleCount; i++){
            const idx = i*3;
            const y = baseTargets[idx+1];
            let t = (y - yMin) / (yMax - yMin);
            t = Math.max(0, Math.min(1, t)); 
            const col = newBase.clone().lerp(newTop, t);
            colorArr[idx] = col.r; colorArr[idx+1] = col.g; colorArr[idx+2] = col.b;
        }
        colorsAttr.needsUpdate = true;

        ribbonMesh.material.color.copy(selectedColor);
        updateBulbVisuals();
      };
    });

    document.getElementById('gradSwitch').onclick = function() {
      this.classList.toggle('on');
      isGradient = this.classList.contains('on');
      updateBulbVisuals();
    };

    document.getElementById('ui-toggle').onclick = () => document.getElementById('ui-panel').classList.toggle('show');

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
